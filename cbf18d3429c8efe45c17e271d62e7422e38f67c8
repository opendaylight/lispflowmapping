{
  "comments": [
    {
      "key": {
        "uuid": "7a1969be_46a1c7a8",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 15
      },
      "lineNbr": 229,
      "author": {
        "id": 654
      },
      "writtenOn": "2017-11-29T03:27:40Z",
      "side": 1,
      "message": "what if the key itself was added as negative in the past? what do you mean by newly added negative? Shouldnt this method be called only when new positive mapping is added to NB?",
      "range": {
        "startLine": 229,
        "startChar": 29,
        "endLine": 229,
        "endChar": 32
      },
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_66ede38b",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 15
      },
      "lineNbr": 229,
      "author": {
        "id": 491
      },
      "writtenOn": "2017-11-29T06:06:41Z",
      "side": 1,
      "message": "If it was added as a negative in the past, and we\u0027re now adding it as a negative again, we want to keep it as a negative and not remove it, since we\u0027re adding it right now. If we added it as a negative in the past, and we\u0027re adding it as a positive, the positive will overwrite the exact match. So this is OK.",
      "parentUuid": "7a1969be_46a1c7a8",
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_975acb81",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 15
      },
      "lineNbr": 229,
      "author": {
        "id": 654
      },
      "writtenOn": "2017-11-29T19:40:11Z",
      "side": 1,
      "message": "We discussed to not remove the key here. Instead never call handleSbNegativeMapping() when a negative mapping is added.",
      "parentUuid": "7a1969be_66ede38b",
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_26a64bc2",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 15
      },
      "lineNbr": 237,
      "author": {
        "id": 654
      },
      "writtenOn": "2017-11-29T03:27:40Z",
      "side": 1,
      "message": "wouldnt this be equivalent of just looking up key in smc, and doing normal longest prefix match? from the longest prefix match we can walk down the tree and remove any node that is subprefix of key and is negative (this can be done inside radixtrie).",
      "range": {
        "startLine": 237,
        "startChar": 31,
        "endLine": 237,
        "endChar": 63
      },
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_c601373b",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 15
      },
      "lineNbr": 237,
      "author": {
        "id": 491
      },
      "writtenOn": "2017-11-29T06:06:41Z",
      "side": 1,
      "message": "No, this is looking up a covering less specific.",
      "parentUuid": "7a1969be_26a64bc2",
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_979f6b03",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 15
      },
      "lineNbr": 237,
      "author": {
        "id": 654
      },
      "writtenOn": "2017-11-29T19:40:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7a1969be_c601373b",
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_c6a2d799",
        "filename": "mappingservice/inmemorydb/src/main/java/org/opendaylight/lispflowmapping/inmemorydb/radixtrie/RadixTrie.java",
        "patchSetId": 15
      },
      "lineNbr": 183,
      "author": {
        "id": 654
      },
      "writtenOn": "2017-11-29T03:27:40Z",
      "side": 1,
      "message": "How is this different than longest prefix match?",
      "range": {
        "startLine": 183,
        "startChar": 7,
        "endLine": 183,
        "endChar": 103
      },
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_06e50fa8",
        "filename": "mappingservice/inmemorydb/src/main/java/org/opendaylight/lispflowmapping/inmemorydb/radixtrie/RadixTrie.java",
        "patchSetId": 15
      },
      "lineNbr": 183,
      "author": {
        "id": 491
      },
      "writtenOn": "2017-11-29T06:06:41Z",
      "side": 1,
      "message": "Longest prefix match is equal or more specific, with the more specific preferred. Covering prefix is equal or less specific, again with the more specific preferred. This is different way of looking up a \"parent\".",
      "parentUuid": "7a1969be_c6a2d799",
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_77a46f57",
        "filename": "mappingservice/inmemorydb/src/main/java/org/opendaylight/lispflowmapping/inmemorydb/radixtrie/RadixTrie.java",
        "patchSetId": 15
      },
      "lineNbr": 183,
      "author": {
        "id": 654
      },
      "writtenOn": "2017-11-29T19:40:11Z",
      "side": 1,
      "message": "So lets make that clear in documenation of method, even if prefix exists, this will return the strictly less specific, and not the prefix itself (so it is not longest prefix match)",
      "parentUuid": "7a1969be_06e50fa8",
      "revId": "cbf18d3429c8efe45c17e271d62e7422e38f67c8",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}