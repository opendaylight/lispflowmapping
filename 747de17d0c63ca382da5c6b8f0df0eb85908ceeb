{
  "comments": [
    {
      "key": {
        "uuid": "1aa4ed85_2260b231",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "If we keep a merged-locators entry in the \"address\" subkey (which would require to also include the timestamp and xTR-ID  info of the xTR-ID with minimum of timestamps) then every time a new Map-Register comes in it only has to be compared to the \"address\" subkey entry to create the new \"address\" merged locators. This is unless the Map-REgister is from same xTR-ID stored at \"address\" merged locators for the minimum timestamp. In that case, we have to walk through all and find the minimum timestamp among all xTR-IDs again. \n\nThis does look a bit more complicated, but reduces processing significantly. thoughts?",
      "range": {
        "startLine": 181,
        "startChar": 46,
        "endLine": 181,
        "endChar": 50
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_2d13c3b9",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T10:32:34Z",
      "side": 1,
      "message": "Probably I\u0027m missing something so let me try some clarifying questions. If the map-register is from the xtr-id holding the minimum of timestamps, then we just update the timestamp, no? In all other cases we have a new \"best\" xtr-id. For all situations, apart from updating the the RECORD key, we should also update the timestamp of the entry under eid/xtr-id (\"/\" used to build a path here), no?",
      "parentUuid": "1aa4ed85_2260b231",
      "range": {
        "startLine": 181,
        "startChar": 46,
        "endLine": 181,
        "endChar": 50
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_824e46c0",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "So aside from locator ordering, there is another issue: I think it is possible that two xTRs registering the same set of locators have different priority for them, for instance one can mark a locator with p\u003d255, while the other has reachability and marks it p\u003d1. In general, I dont know how MS should deal with differing priorities, but I think here the HashSet should be on the LispAddress inside the locator records.  And I think if a locator is ever marked with 255 it has to remain 255 in the resulting merged locators. The rest of values for p has less importance, but still not sure how they are merged , maybe algorithm can be keep largest value of priority for a locator?",
      "range": {
        "startLine": 184,
        "startChar": 42,
        "endLine": 184,
        "endChar": 44
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_cd6a2f1a",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T10:32:34Z",
      "side": 1,
      "message": "Good point.",
      "parentUuid": "1aa4ed85_824e46c0",
      "range": {
        "startLine": 184,
        "startChar": 42,
        "endLine": 184,
        "endChar": 44
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_6266aa53",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "Would it be better to have get mapping (all) always return a list and base this decision on the size? also probably need to check for null MappingRecord.",
      "range": {
        "startLine": 189,
        "startChar": 46,
        "endLine": 189,
        "endChar": 47
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_2d2c2302",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T10:32:34Z",
      "side": 1,
      "message": "I think we should return a list or one record based on the syntax of getMapping, which as I mentioned in another comment, should have the option to select an xtr-id (when precise lookups are done) or the option not to select one, when all entries under the eid key should be returned. This way, merge should be called only when we have a List\u003cObject\u003e.",
      "parentUuid": "1aa4ed85_6266aa53",
      "range": {
        "startLine": 189,
        "startChar": 46,
        "endLine": 189,
        "endChar": 47
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_42612e38",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "What if we do the merge on store/write, and store the merged mapping in the subkey address? This way, we always have a ready to go mapping for SB, and a detailed, per xTR mappings list for future merge processings when merge is on and for monitoring and stats when merge is off. Thougts?",
      "range": {
        "startLine": 214,
        "startChar": 61,
        "endLine": 214,
        "endChar": 63
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_7f6c019d",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-19T15:19:50Z",
      "side": 1,
      "message": "I just realized that both this patch and the overwrite one require that the caches be aware of the type of data (value) that\u0027s stored in them. Could we avoid that and have all the logic needing this information outside, in the MappingSystem? As an advantage we should be able to use overwrite and merge with other caches, if need be. Of course, this can be done only if certain type of functions, like one that retrieves all records under xtr-id, are  part of the IMapCache interface.",
      "range": {
        "startLine": 145,
        "startChar": 23,
        "endLine": 145,
        "endChar": 36
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_42c84e22",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "I am not religous about keeping MapCaches value agnostic, but it is a good rule for keeping house clean if it doesnt add too much overhead. \nIn general, I think if getMapping(merge\u003d0) we should return all mapping records under the xTR-ID_RECORD subkey.\nWhen getMapping(merge\u003d1)  we return re pre-computed merged-locators record under RECORD subkey. \nAt addMapping if merge\u003dtrue we merge with record under subkey RECORD and store both the entry and update RECORD subkey if needed, and if merge\u003dfalse, we still store the record, and also update the subkey RECORD. Thoughts?",
      "range": {
        "startLine": 146,
        "startChar": 41,
        "endLine": 146,
        "endChar": 42
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_8dee77eb",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T10:32:34Z",
      "side": 1,
      "message": "I was alluding to this but didn\u0027t make it clear in the previous comment. I think that map-caches shouldn\u0027t know what merge/overwrite is. They\u0027re just databases that offer an API whereby you can write either under the xtr-id node or straight under the eid key. Based on the value of merge/overwrite, you select where to write in the MappingSystem. Therefore yes, getMapping should be overloaded and if called without xtr-id set, it should return everything under eid (i.e., all xtr-id associated records).\nI\u0027m not sure I follow the second part of the comment, but I think you\u0027re suggesting to have in RECORD always a precomputed merged record (if merge is on). That sounds reasonable to me.",
      "parentUuid": "1aa4ed85_42c84e22",
      "range": {
        "startLine": 146,
        "startChar": 41,
        "endLine": 146,
        "endChar": 42
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_a24b42af",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 151,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "now I cant remember, where do we check the timestamps? you probably should add only valid ones, and ignore stale mappings.",
      "range": {
        "startLine": 151,
        "startChar": 16,
        "endLine": 151,
        "endChar": 17
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}