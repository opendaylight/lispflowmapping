{
  "comments": [
    {
      "key": {
        "uuid": "1aa4ed85_2260b231",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "If we keep a merged-locators entry in the \"address\" subkey (which would require to also include the timestamp and xTR-ID  info of the xTR-ID with minimum of timestamps) then every time a new Map-Register comes in it only has to be compared to the \"address\" subkey entry to create the new \"address\" merged locators. This is unless the Map-REgister is from same xTR-ID stored at \"address\" merged locators for the minimum timestamp. In that case, we have to walk through all and find the minimum timestamp among all xTR-IDs again. \n\nThis does look a bit more complicated, but reduces processing significantly. thoughts?",
      "range": {
        "startLine": 181,
        "startChar": 46,
        "endLine": 181,
        "endChar": 50
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_2d13c3b9",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T10:32:34Z",
      "side": 1,
      "message": "Probably I\u0027m missing something so let me try some clarifying questions. If the map-register is from the xtr-id holding the minimum of timestamps, then we just update the timestamp, no? In all other cases we have a new \"best\" xtr-id. For all situations, apart from updating the the RECORD key, we should also update the timestamp of the entry under eid/xtr-id (\"/\" used to build a path here), no?",
      "parentUuid": "1aa4ed85_2260b231",
      "range": {
        "startLine": 181,
        "startChar": 46,
        "endLine": 181,
        "endChar": 50
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_8e5f4d0e",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T22:21:14Z",
      "side": 1,
      "message": "We cant just update the timestamp, because I think the \"merged-locators\" has to be marked with the minimum of the timestamps. So if the new Map-Register is from the same xTR-ID, we need to find the new minimum timestamp, and the associated xTR-ID to update the \"merged-locators\" or subkey RECORD. This is iff we do it the way I mentioned above, which is always keeping a merged-locators mapping record under RECORD subkey.",
      "parentUuid": "1aa4ed85_2d13c3b9",
      "range": {
        "startLine": 181,
        "startChar": 46,
        "endLine": 181,
        "endChar": 50
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_824e46c0",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "So aside from locator ordering, there is another issue: I think it is possible that two xTRs registering the same set of locators have different priority for them, for instance one can mark a locator with p\u003d255, while the other has reachability and marks it p\u003d1. In general, I dont know how MS should deal with differing priorities, but I think here the HashSet should be on the LispAddress inside the locator records.  And I think if a locator is ever marked with 255 it has to remain 255 in the resulting merged locators. The rest of values for p has less importance, but still not sure how they are merged , maybe algorithm can be keep largest value of priority for a locator?",
      "range": {
        "startLine": 184,
        "startChar": 42,
        "endLine": 184,
        "endChar": 44
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_cd6a2f1a",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T10:32:34Z",
      "side": 1,
      "message": "Good point.",
      "parentUuid": "1aa4ed85_824e46c0",
      "range": {
        "startLine": 184,
        "startChar": 42,
        "endLine": 184,
        "endChar": 44
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_2dbd0369",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 491
      },
      "writtenOn": "2015-12-21T11:13:38Z",
      "side": 1,
      "message": "Absolutely. As I said in my last email, this is by far not finished, and I didn\u0027t yet full thought merging through. All valid points.",
      "parentUuid": "1aa4ed85_824e46c0",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_2e9c19c0",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T22:21:14Z",
      "side": 1,
      "message": "Ack. My point was, that we should get the SET of locators, not the SET of  MappingRecord.",
      "parentUuid": "1aa4ed85_2dbd0369",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_6266aa53",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "Would it be better to have get mapping (all) always return a list and base this decision on the size? also probably need to check for null MappingRecord.",
      "range": {
        "startLine": 189,
        "startChar": 46,
        "endLine": 189,
        "endChar": 47
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_2d2c2302",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T10:32:34Z",
      "side": 1,
      "message": "I think we should return a list or one record based on the syntax of getMapping, which as I mentioned in another comment, should have the option to select an xtr-id (when precise lookups are done) or the option not to select one, when all entries under the eid key should be returned. This way, merge should be called only when we have a List\u003cObject\u003e.",
      "parentUuid": "1aa4ed85_6266aa53",
      "range": {
        "startLine": 189,
        "startChar": 46,
        "endLine": 189,
        "endChar": 47
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_cdad4f33",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 491
      },
      "writtenOn": "2015-12-21T11:13:38Z",
      "side": 1,
      "message": "It was my initial choice, but then I was thrown off by the need of extra new ArrayList\u003c\u003e every time we return a single mapping. But I guess if merge\u003d1 this is ok, so I will update the patch (I agree this is more elegant).",
      "parentUuid": "1aa4ed85_6266aa53",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_6daa1b1b",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 491
      },
      "writtenOn": "2015-12-21T11:13:38Z",
      "side": 1,
      "message": "Since you insist, I\u0027ll add that possibility too ;)",
      "parentUuid": "1aa4ed85_2d2c2302",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_c8f53d84",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T14:58:34Z",
      "side": 1,
      "message": "Just to be clear, you plan on having 2 methods, one that returns an ArrayList and another that returns just one Object, right?",
      "parentUuid": "1aa4ed85_cdad4f33",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_eea5a104",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T22:21:14Z",
      "side": 1,
      "message": "So iff we consider storing a ready to go merged record under subkey RECORD,  we would need 3 options: return a specific xTR-ID, return all xTR-IDs, return just the subkey RECORD.",
      "parentUuid": "1aa4ed85_c8f53d84",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_42612e38",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "What if we do the merge on store/write, and store the merged mapping in the subkey address? This way, we always have a ready to go mapping for SB, and a detailed, per xTR mappings list for future merge processings when merge is on and for monitoring and stats when merge is off. Thougts?",
      "range": {
        "startLine": 214,
        "startChar": 61,
        "endLine": 214,
        "endChar": 63
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_ed6dab05",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 491
      },
      "writtenOn": "2015-12-21T11:13:38Z",
      "side": 1,
      "message": "As I said above, this may have some performance impact on merge, but right now it\u0027s just speculation how much. In addition, it will not be difficult to change back to the original merge-on-retrieve design, if we think that\u0027s better, so we can go with this approach.",
      "parentUuid": "1aa4ed85_42612e38",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_aeafa9e2",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/MappingSystem.java",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T22:21:14Z",
      "side": 1,
      "message": "I just think it is a bit cleaner, since we can always have a merged-locators ready under RECORD subkey. Then the getMapping can always return only the SUBKEY RECORD when merge\u003d1 and all the records under xTR-RECORD when merge\u003d0.  I dont think we need two merge methods as Florin is pointing I think.",
      "parentUuid": "1aa4ed85_ed6dab05",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_7f6c019d",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-19T15:19:50Z",
      "side": 1,
      "message": "I just realized that both this patch and the overwrite one require that the caches be aware of the type of data (value) that\u0027s stored in them. Could we avoid that and have all the logic needing this information outside, in the MappingSystem? As an advantage we should be able to use overwrite and merge with other caches, if need be. Of course, this can be done only if certain type of functions, like one that retrieves all records under xtr-id, are  part of the IMapCache interface.",
      "range": {
        "startLine": 145,
        "startChar": 23,
        "endLine": 145,
        "endChar": 36
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_6dfc5b3f",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 491
      },
      "writtenOn": "2015-12-21T11:13:38Z",
      "side": 1,
      "message": "I was expecting this comment to hit in the previous commit :)  Since I was on the fence on that. Since you didn\u0027t object, I continued with keeping the API stable (since we need an API change for this).\n\nHowever, I do agree keeping the caches agnostic is better, so if there\u0027s no objections to the API changes, I\u0027ll send out a small patch first for the overwrite feature, and then update this patch too.",
      "parentUuid": "1aa4ed85_7f6c019d",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_282c1102",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T14:58:34Z",
      "side": 1,
      "message": "Yeah, I missed it last time :-(",
      "parentUuid": "1aa4ed85_6dfc5b3f",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_42c84e22",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "I am not religous about keeping MapCaches value agnostic, but it is a good rule for keeping house clean if it doesnt add too much overhead. \nIn general, I think if getMapping(merge\u003d0) we should return all mapping records under the xTR-ID_RECORD subkey.\nWhen getMapping(merge\u003d1)  we return re pre-computed merged-locators record under RECORD subkey. \nAt addMapping if merge\u003dtrue we merge with record under subkey RECORD and store both the entry and update RECORD subkey if needed, and if merge\u003dfalse, we still store the record, and also update the subkey RECORD. Thoughts?",
      "range": {
        "startLine": 146,
        "startChar": 41,
        "endLine": 146,
        "endChar": 42
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_8dee77eb",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T10:32:34Z",
      "side": 1,
      "message": "I was alluding to this but didn\u0027t make it clear in the previous comment. I think that map-caches shouldn\u0027t know what merge/overwrite is. They\u0027re just databases that offer an API whereby you can write either under the xtr-id node or straight under the eid key. Based on the value of merge/overwrite, you select where to write in the MappingSystem. Therefore yes, getMapping should be overloaded and if called without xtr-id set, it should return everything under eid (i.e., all xtr-id associated records).\nI\u0027m not sure I follow the second part of the comment, but I think you\u0027re suggesting to have in RECORD always a precomputed merged record (if merge is on). That sounds reasonable to me.",
      "parentUuid": "1aa4ed85_42c84e22",
      "range": {
        "startLine": 146,
        "startChar": 41,
        "endLine": 146,
        "endChar": 42
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_ad89f3cb",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 491
      },
      "writtenOn": "2015-12-21T11:13:38Z",
      "side": 1,
      "message": "Right, since overwrite is user tunable, it makes sense to return everything when merge\u003d0, overwrite\u003d0.\n\nAs for the merge-on-store, we discussed this at length, and the consensus was not to do it. Either way, changing when the merge is done is relatively simple, so I don\u0027t mind going for this, and if profiling and real-world requirements (e.g., optimize for map-register, or any other functional need) makes us change this, we can.",
      "parentUuid": "1aa4ed85_8dee77eb",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_884665be",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 1966
      },
      "writtenOn": "2015-12-21T14:58:34Z",
      "side": 1,
      "message": "Fine by me!",
      "parentUuid": "1aa4ed85_ad89f3cb",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_4ed63551",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T22:21:14Z",
      "side": 1,
      "message": "Agree with this, if we dont keep a merged-locators record under RECORD subkey. If xTR-ID is not set, and we do keep a merged-locators record under RECORD subkey, then we need another discriminator to return all xTR-ID records, or just the subkey RECORD. Right?",
      "parentUuid": "1aa4ed85_8dee77eb",
      "range": {
        "startLine": 146,
        "startChar": 41,
        "endLine": 146,
        "endChar": 42
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_aec48992",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T22:21:14Z",
      "side": 1,
      "message": "Right. Since then though, I noticed that IOS MS actually does keep a list of merged-locators. besides considering that it will reduce the amount of processing needed in general to build the merge result if we incrementally keep a merged-locators list, I am thinking it may be a good idea to start this way. As you said this is changeable in future. But now my vote is to go with incrementally building the merged-locators at store time, and keep it under subkey RECORD. This way, for a Map-Reply, whatever is in subkey RECORD is always the answer. on Map-Register, depending on (merge/overwrite/etc) we have to do different things.",
      "parentUuid": "1aa4ed85_ad89f3cb",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_a24b42af",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 151,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T06:21:32Z",
      "side": 1,
      "message": "now I cant remember, where do we check the timestamps? you probably should add only valid ones, and ignore stale mappings.",
      "range": {
        "startLine": 151,
        "startChar": 16,
        "endLine": 151,
        "endChar": 17
      },
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_ad02533c",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 151,
      "author": {
        "id": 491
      },
      "writtenOn": "2015-12-21T11:13:38Z",
      "side": 1,
      "message": "We don\u0027t. Lazy entry expiry wasn\u0027t implemented yet. I like to keeps commits atomic, so that was planned as separate commit.",
      "parentUuid": "1aa4ed85_a24b42af",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aa4ed85_2eead90f",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/mapcache/SimpleMapCache.java",
        "patchSetId": 1
      },
      "lineNbr": 151,
      "author": {
        "id": 654
      },
      "writtenOn": "2015-12-21T22:21:14Z",
      "side": 1,
      "message": "Ack. But we should keep it in mind and carry associated time-stamps with the records if we decide to keep a merged-locators record.",
      "parentUuid": "1aa4ed85_ad02533c",
      "revId": "747de17d0c63ca382da5c6b8f0df0eb85908ceeb",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}