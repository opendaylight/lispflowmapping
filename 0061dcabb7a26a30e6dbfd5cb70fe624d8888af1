{
  "comments": [
    {
      "key": {
        "uuid": "9a3d3df0_b93053e9",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 1966
      },
      "writtenOn": "2016-02-06T15:40:33Z",
      "side": 1,
      "message": "After an out of band chat with Lori we realized this can happen because we\u0027re writing asynchronously to the DAO. That is, we\u0027re looking the entry up and it hasn\u0027t been saved in a map-cache yet.\n\nBut, I guess, that the most important implication here is that we can\u0027t guarantee that what we\u0027re getting from the map-cache, when merging is on, is the actual merged record. We need to wait for the whole chain: \"write to datastore-\u003e MappingDataListener -\u003e MapCache(s) -\u003e dao\" to finish. \n\nVina, what do you think?",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_793d2bbb",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 491
      },
      "writtenOn": "2016-02-06T15:43:22Z",
      "side": 1,
      "message": "I don\u0027t think that this happens only with merge on. However, the time scales are different for the code execution race conditions and on the wire packet exchange, so as long as in the code we account for this, it probably won\u0027t be a problem on the wire.",
      "parentUuid": "9a3d3df0_b93053e9",
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_b947b34a",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 1966
      },
      "writtenOn": "2016-02-06T16:04:47Z",
      "side": 1,
      "message": "When merging is off, the map-notify is sent without checking the map-cache. So we avoid the race condition. When merging is on however, we really need some indication that the merged mapping has been saved, otherwise we send map-notifies using the old mapping record. \n\nNow, it would be worth noting that when the next, periodic, map-register comes, we will return the right merged mapping. Maybe we can live with this :-)",
      "parentUuid": "9a3d3df0_793d2bbb",
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_d96d579a",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 654
      },
      "writtenOn": "2016-02-06T19:31:09Z",
      "side": 1,
      "message": "Well, I am thinking we are having too many issues with SB registrations going to the datastore and then Dao. If we are going to check for notifications of onMappingChanged to see if it is from SB vs NB, maybe we can change the path for SB to go to dao first and then to datastore. Or even if we dont change the order, we directly write to both dao and datastore, and then ignore datastore notifications that are result of SB. We may have to revisit this when clustering is on, but for single node should work.. Thoughts?",
      "parentUuid": "9a3d3df0_b93053e9",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_79f52bca",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 654
      },
      "writtenOn": "2016-02-06T19:57:10Z",
      "side": 1,
      "message": "And another problem with this is: if it can be null, it can also be incorrect if it is not null. because  it can be the old merged record not considering the new MAp-Register, which would be pure wrong. So no, we cant just skip this.",
      "parentUuid": "9a3d3df0_d96d579a",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_59282734",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 1966
      },
      "writtenOn": "2016-02-06T20:38:13Z",
      "side": 1,
      "message": "It may very well be the only solution to this problem. We could convert the MappingSystem in a write-through cache for southbound mappings. The underlying assumption in this case, I think, is that the MappingSystem won\u0027t listen for datastore updates on the SB branch.",
      "parentUuid": "9a3d3df0_d96d579a",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_19bcdfdb",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 654
      },
      "writtenOn": "2016-02-07T01:15:52Z",
      "side": 1,
      "message": "well, it is not an assumption, right? we get the notifications, we check the origin, if it is SB, we ignore it. Similar what Lori already submitted for SMR.",
      "parentUuid": "9a3d3df0_59282734",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_59b667fb",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 1966
      },
      "writtenOn": "2016-02-07T01:31:15Z",
      "side": 1,
      "message": "I may have not explained it well. The point is that we\u0027re assuming nobody else but the LispMappingService/MapCache will write to the SB datastore. This because we don\u0027t want to listen to updates and figure out if the LispDataStore/MapCache wrote something, in which case we can ignore it (as you mentioned), OR if somebody else did, in which case, we can\u0027t ignore it and have write it to the MapCache as well.",
      "parentUuid": "9a3d3df0_19bcdfdb",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}