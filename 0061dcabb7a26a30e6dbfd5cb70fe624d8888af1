{
  "comments": [
    {
      "key": {
        "uuid": "9a3d3df0_b93053e9",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 1966
      },
      "writtenOn": "2016-02-06T15:40:33Z",
      "side": 1,
      "message": "After an out of band chat with Lori we realized this can happen because we\u0027re writing asynchronously to the DAO. That is, we\u0027re looking the entry up and it hasn\u0027t been saved in a map-cache yet.\n\nBut, I guess, that the most important implication here is that we can\u0027t guarantee that what we\u0027re getting from the map-cache, when merging is on, is the actual merged record. We need to wait for the whole chain: \"write to datastore-\u003e MappingDataListener -\u003e MapCache(s) -\u003e dao\" to finish. \n\nVina, what do you think?",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_793d2bbb",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 491
      },
      "writtenOn": "2016-02-06T15:43:22Z",
      "side": 1,
      "message": "I don\u0027t think that this happens only with merge on. However, the time scales are different for the code execution race conditions and on the wire packet exchange, so as long as in the code we account for this, it probably won\u0027t be a problem on the wire.",
      "parentUuid": "9a3d3df0_b93053e9",
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_b947b34a",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 1966
      },
      "writtenOn": "2016-02-06T16:04:47Z",
      "side": 1,
      "message": "When merging is off, the map-notify is sent without checking the map-cache. So we avoid the race condition. When merging is on however, we really need some indication that the merged mapping has been saved, otherwise we send map-notifies using the old mapping record. \n\nNow, it would be worth noting that when the next, periodic, map-register comes, we will return the right merged mapping. Maybe we can live with this :-)",
      "parentUuid": "9a3d3df0_793d2bbb",
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_d96d579a",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 654
      },
      "writtenOn": "2016-02-06T19:31:09Z",
      "side": 1,
      "message": "Well, I am thinking we are having too many issues with SB registrations going to the datastore and then Dao. If we are going to check for notifications of onMappingChanged to see if it is from SB vs NB, maybe we can change the path for SB to go to dao first and then to datastore. Or even if we dont change the order, we directly write to both dao and datastore, and then ignore datastore notifications that are result of SB. We may have to revisit this when clustering is on, but for single node should work.. Thoughts?",
      "parentUuid": "9a3d3df0_b93053e9",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_79f52bca",
        "filename": "mappingservice/implementation/src/main/java/org/opendaylight/lispflowmapping/implementation/lisp/MapServer.java",
        "patchSetId": 3
      },
      "lineNbr": 150,
      "author": {
        "id": 654
      },
      "writtenOn": "2016-02-06T19:57:10Z",
      "side": 1,
      "message": "And another problem with this is: if it can be null, it can also be incorrect if it is not null. because  it can be the old merged record not considering the new MAp-Register, which would be pure wrong. So no, we cant just skip this.",
      "parentUuid": "9a3d3df0_d96d579a",
      "range": {
        "startLine": 150,
        "startChar": 20,
        "endLine": 150,
        "endChar": 48
      },
      "revId": "0061dcabb7a26a30e6dbfd5cb70fe624d8888af1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}